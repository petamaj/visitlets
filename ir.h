#pragma once
#include <ciso646>
#include <cassert>
#include <cstdlib>
#include <cstdint>
#include <vector>
#include <set>



#include <iostream>
#include <iomanip>

/** General notes
-------------

If it is struct, any virtuality is not allowed, if it is class, anything is allowed.
*/


/** Slim instructions

Slim instructions are mere structs that offer no-cost nicer abstractions over the data in the code vector. They should not do anything but accessing the data (all data is constant) and act as the lowest level of the API.

A pointer to an instruction should also be used as a location handle for an analysis.
*/
struct Instruction {

    typedef uint16_t BranchTarget;

    enum class Opcode : uint16_t {
        Push,
        Add,
        Sub,
        Call,
        Br,
    };

    size_t size() const;

    Opcode const opcode;

    static char const * opcodeToStr(Opcode opcode) {
        switch (opcode) {
            case Opcode::Push:
                return "Push";
            case Opcode::Add:
                return "Add";
            case Opcode::Sub:
                return "Sub";
            case Opcode::Call:
                return "Call";
            case Opcode::Br:
                return "Br";
            default:
                return "???";
        }
    }


    struct Push;
    struct Add;
    struct Sub;
    struct Call;
    struct Br;

protected:
    Instruction(Opcode opcode) :
        opcode(opcode) {}

private:
    void * operator new (size_t) = delete;
    void * operator new[](size_t) = delete;
    void   operator delete (void *) = delete;
    void   operator delete[](void *) = delete;
};

struct Instruction::Push : public Instruction {

    uint16_t const index;

    Push(uint16_t index) :
        Instruction(Opcode::Push),
        index(index) {}

    friend std::ostream & operator << (std::ostream & stream, Push const & ins) {
        stream << "PUSH " << ins.index;
        return stream;
    }
};

struct Instruction::Add : public Instruction {
    Add() :
        Instruction(Opcode::Add) {}

    friend std::ostream & operator << (std::ostream & stream, Add const & ins) {
        stream << "ADD";
        return stream;
    }
};

struct Instruction::Sub : public Instruction {
    Sub() :
        Instruction(Opcode::Sub) {}

    friend std::ostream & operator << (std::ostream & stream, Sub const & ins) {
        stream << "SUB";
        return stream;
    }
};

struct Instruction::Call : public Instruction {
    uint8_t const arguments;
    Call(uint8_t arguments) :
        Instruction(Opcode::Call),
        arguments(arguments) {}

    friend std::ostream & operator << (std::ostream & stream, Call const & ins) {
        stream << "CALL " << ins.arguments;
        return stream;
    }
};

struct Instruction::Br : public Instruction {
    BranchTarget const target;
    Br(BranchTarget target) :
        Instruction(Opcode::Br),
        target(target) {}

    friend std::ostream & operator << (std::ostream & stream, Br const & ins) {
        stream << "BR " << ins.target;
        return stream;
    }
};

// TODO this can be autogenerated
inline size_t Instruction::size() const {
    switch (opcode) {
        case Opcode::Push:
            return sizeof(Instruction::Push);
        case Opcode::Add:
            return sizeof(Instruction::Add);
        case Opcode::Sub:
            return sizeof(Instruction::Sub);
        case Opcode::Call:
            return sizeof(Instruction::Call);
        case Opcode::Br:
            return sizeof(Instruction::Br);
        default:
            assert(false and "we have tested all instructions already");
    }
}


class Code;
/** Constant pool.

Currently has only integers in it. In reality, integers will likely be immediate arguments to the instructions, and constant pool would contain more complex data such as SEXPs, symbols, and source code references.

The constant pool is shared amongst all versions of the code for particular function - the idea is that the first, least optimized version will likely require all constants (the most symbols, source refs and complex constants), while the optimized versions will most likely only use subsets.
*/
class ConstantPool {
public:

    int operator [] (size_t index) const {
        return values_[index];
    }

    size_t append(int value) {
        // TODO this should of course check for duplicates
        size_t result = values_.size();
        values_.push_back(value);
        return result;
    }

private:

    friend class Code;

    ConstantPool() = default;

    std::vector<int> values_;

    std::set<Code*> versions_;

    void attach(Code * version) {
        versions_.insert(version);
    }

    void detach(Code * version) {
        versions_.erase(version);
    }
};

/** The code buffer.

This should be so much more than a simple vector as it is now.

TODO Revisit this and make more performant.
*/
class Code {
public:
    /** First version constructor which also creates the constant pool.
    */
    Code() :
        pool(*new ConstantPool()) {
        pool.attach(this);
    }

    template<typename INS>
    INS const * at(size_t index) const {
        return reinterpret_cast<INS const *>(buffer_.data() + index);
    }

    Instruction const * operator [] (size_t index) const {
        return reinterpret_cast<Instruction const*>(buffer_.data() + index);
    }

    // TODO this should return the pointer to the instruction, to ease building but for that I need more clever code buffer
    template<typename INS>
    void append(INS const & ins) {
        size_t from = buffer_.size();
        buffer_.resize(from + sizeof(INS));
        // memcpy so that we do not have to bother with copy constructors and assignments
        memcpy(buffer_.data() + from, &ins, sizeof(INS));
    }

    class iterator {
    public:
        iterator(iterator const & from) = default;
        iterator & operator = (iterator const & from) = default;

        template<typename INS>
        INS * at() const {
            return reinterpret_cast<INS *>(current_);
        }

        Instruction & operator * () {
            return *reinterpret_cast<Instruction *>(current_);
        }

        Instruction * operator -> () {
            return reinterpret_cast<Instruction *>(current_);
        }

        iterator & operator ++ () {
            current_ += at<Instruction>()->size();
            return *this;
        }

        bool operator != (iterator const & other) const {
            return current_ != other.current_;
        }

    private:
        friend class Code;

        iterator(char * start) :
            current_(start) {}

        char * current_;
    };

    iterator begin() {
        return iterator(buffer_.data());
    }

    iterator end() {
        return iterator(buffer_.data() + buffer_.size());
    }




    ConstantPool & pool;

private:
    friend std::ostream & operator << (std::ostream & stream, Code & code) {
        for (auto i = code.begin(), e = code.end(); i != e; ++i) {
            stream << std::setw(5) << reinterpret_cast<char*>(i.at<Instruction>()) - code.buffer_.data() << " ";
            switch (i->opcode) {
                case Instruction::Opcode::Push:
                    stream << *i.at<Instruction::Push>();
                    break;
                case Instruction::Opcode::Add:
                    stream << *i.at<Instruction::Add>();
                    break;
                case Instruction::Opcode::Sub:
                    stream << *i.at<Instruction::Sub>();
                    break;
                case Instruction::Opcode::Call:
                    stream << *i.at<Instruction::Call>();
                    break;
                case Instruction::Opcode::Br:
                    stream << *i.at<Instruction::Br>();
                    break;
                default:
                    stream << "??? " << static_cast<uint16_t>(i->opcode);
            }
            stream << std::endl;
        }

        return stream;
    }

    std::vector<char> buffer_;

};
